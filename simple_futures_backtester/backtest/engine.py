"""Backtesting engine using VectorBT Portfolio.

Provides BacktestEngine that wraps VectorBT's Portfolio.from_signals()
to run backtests on signal arrays generated by strategies. Handles signal
conversion from states (-1/0/1) to entry/exit events.

Usage:
    >>> from simple_futures_backtester.backtest import BacktestEngine
    >>> from simple_futures_backtester.config import BacktestConfig
    >>> import numpy as np
    >>>
    >>> # Generate signals (from strategy)
    >>> signals = np.array([0, 0, 1, 1, 0, -1, -1, 0], dtype=np.int32)
    >>> close_prices = np.array([100, 101, 102, 103, 102, 101, 100, 101])
    >>>
    >>> # Run backtest
    >>> config = BacktestConfig(initial_capital=100000, fees=0.0001)
    >>> engine = BacktestEngine()
    >>> result = engine.run(close_prices, signals, config)
    >>>
    >>> # Access results
    >>> print(f"Total Return: {result.total_return:.2%}")
    >>> print(f"Sharpe Ratio: {result.sharpe_ratio:.2f}")
    >>> print(f"Number of Trades: {result.n_trades}")
"""

from __future__ import annotations

import hashlib
import math
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import TYPE_CHECKING

import numpy as np
import pandas as pd
import vectorbt as vbt
from numpy.typing import NDArray

from simple_futures_backtester.config import BacktestConfig

if TYPE_CHECKING:
    pass


# Mapping from BacktestConfig size_type to VectorBT SizeType
# BacktestConfig uses: "fixed", "percent", "target"
# VectorBT uses: Amount, Value, Percent, TargetAmount, TargetValue, TargetPercent
_SIZE_TYPE_MAP = {
    "fixed": "Amount",       # Fixed number of contracts/units
    "amount": "Amount",      # Alias for fixed
    "value": "Value",        # Fixed dollar value
    "percent": "Percent",    # Percentage of available resources
    "target": "TargetAmount",  # Target position size
    "target_amount": "TargetAmount",
    "target_value": "TargetValue",
    "target_percent": "TargetPercent",
}


@dataclass
class BacktestResult:
    """Results from a backtest run.

    Contains both scalar metrics and time-series data for analysis and
    visualization. All PnL metrics are in price units (not dollars) unless
    wrapped with FuturesPortfolio for point value conversion.

    Attributes:
        total_return: Total return as decimal (0.15 = 15% return).
        sharpe_ratio: Sharpe ratio (risk-adjusted return).
        sortino_ratio: Sortino ratio (downside-adjusted return).
        max_drawdown: Maximum drawdown as decimal (0.20 = 20% drawdown).
        win_rate: Winning trade percentage as decimal (0.60 = 60% win rate).
        profit_factor: Ratio of gross profits to gross losses.
        n_trades: Total number of closed trades.
        avg_trade: Average trade profit/loss in price units.
        equity_curve: Portfolio value at each bar as float64 array.
        drawdown_curve: Drawdown percentage at each bar as float64 array.
        trades: DataFrame of all trades with entry/exit details.
        config_hash: SHA256 hash of the BacktestConfig used.
        timestamp: ISO 8601 timestamp of when backtest was run.
    """

    # Scalar metrics
    total_return: float
    sharpe_ratio: float
    sortino_ratio: float
    max_drawdown: float
    win_rate: float
    profit_factor: float
    n_trades: int
    avg_trade: float

    # Time-series data
    equity_curve: NDArray[np.float64]
    drawdown_curve: NDArray[np.float64]
    trades: pd.DataFrame

    # Metadata
    config_hash: str = ""
    timestamp: str = ""


def _safe_float(value: float, default: float = 0.0) -> float:
    """Safely convert value to float, handling NaN, inf, and None.

    Args:
        value: Value to convert.
        default: Default value if conversion fails or value is NaN/inf.

    Returns:
        Float value or default if invalid.
    """
    if value is None:
        return default
    try:
        result = float(value)
        if math.isnan(result) or math.isinf(result):
            return default
        return result
    except (TypeError, ValueError):
        return default


def _safe_int(value: int, default: int = 0) -> int:
    """Safely convert value to int, handling NaN, inf, and None.

    Args:
        value: Value to convert.
        default: Default value if conversion fails.

    Returns:
        Int value or default if invalid.
    """
    if value is None:
        return default
    try:
        fval = float(value)
        if math.isnan(fval) or math.isinf(fval):
            return default
        return int(fval)
    except (TypeError, ValueError):
        return default


def _compute_config_hash(config: BacktestConfig) -> str:
    """Compute SHA256 hash of BacktestConfig for reproducibility tracking.

    Args:
        config: BacktestConfig to hash.

    Returns:
        Hexadecimal SHA256 hash of the config fields.
    """
    config_str = (
        f"initial_capital={config.initial_capital},"
        f"fees={config.fees},"
        f"slippage={config.slippage},"
        f"size={config.size},"
        f"size_type={config.size_type},"
        f"freq={config.freq}"
    )
    return hashlib.sha256(config_str.encode("utf-8")).hexdigest()


class BacktestEngine:
    """Backtesting engine using VectorBT Portfolio.

    Wraps VectorBT's Portfolio.from_signals() to run backtests on signal
    arrays generated by strategies. Converts signal states (-1/0/1) into
    entry/exit events and applies backtest configuration.

    The engine is stateless and can be reused for multiple backtests.
    Each run() call creates a new VectorBT portfolio and extracts results.

    Example:
        >>> engine = BacktestEngine()
        >>> config = BacktestConfig(initial_capital=100000)
        >>> result = engine.run(close_prices, signals, config)
    """

    def run(
        self,
        close: NDArray[np.float64],
        signals: NDArray[np.int32],
        config: BacktestConfig,
    ) -> BacktestResult:
        """Run backtest on signal array.

        Converts signal states (-1/0/1) to entry/exit events, runs VectorBT
        portfolio simulation, and extracts all metrics into BacktestResult.

        Signal Conversion:
            - Long entry: Signal changes from non-1 to 1
            - Short entry: Signal changes from non--1 to -1
            - Exits: Signal changes to 0 or opposite direction

        Args:
            close: Closing prices as float64 array.
            signals: Signal array as int32 with values -1 (short), 0 (flat), 1 (long).
            config: BacktestConfig with capital, fees, slippage, etc.

        Returns:
            BacktestResult with all metrics, equity curve, drawdown curve, and trades.

        Raises:
            ValueError: If close and signals have different lengths.
            ValueError: If signals contain invalid values (not -1, 0, or 1).
        """
        # Validate inputs
        if len(close) != len(signals):
            raise ValueError(
                f"close and signals must have same length, "
                f"got {len(close)} and {len(signals)}"
            )

        # Validate signal values
        unique_signals = np.unique(signals)
        valid_signals = {-1, 0, 1}
        invalid = set(unique_signals) - valid_signals
        if invalid:
            raise ValueError(f"signals must contain only -1, 0, 1, found: {invalid}")

        # Convert signal array to pandas Series for shift operation
        signals_series = pd.Series(signals, dtype=np.int32)

        # Long entries: signal changes from non-1 to 1
        long_entries = (signals_series == 1) & (signals_series.shift(1) != 1)

        # Short entries: signal changes from non--1 to -1
        short_entries = (signals_series == -1) & (signals_series.shift(1) != -1)

        # Long exits: signal changes from 1 to non-1 (0 or -1)
        long_exits = (signals_series != 1) & (signals_series.shift(1) == 1)

        # Short exits: signal changes from -1 to non--1 (0 or 1)
        short_exits = (signals_series != -1) & (signals_series.shift(1) == -1)

        # Handle first bar (NaN after shift -> fillna(False))
        long_entries = long_entries.fillna(False)
        short_entries = short_entries.fillna(False)
        long_exits = long_exits.fillna(False)
        short_exits = short_exits.fillna(False)

        # Convert to numpy boolean arrays
        long_entries_arr = long_entries.values.astype(bool)
        short_entries_arr = short_entries.values.astype(bool)
        long_exits_arr = long_exits.values.astype(bool)
        short_exits_arr = short_exits.values.astype(bool)

        # Create pandas Series for price data with datetime index
        close_series = pd.Series(
            close,
            index=pd.date_range("2020-01-01", periods=len(close), freq=config.freq),
        )

        # Map size_type from BacktestConfig format to VectorBT format
        vbt_size_type = _SIZE_TYPE_MAP.get(config.size_type.lower(), "Amount")

        # Create portfolio with bi-directional trading
        # When providing short_entries explicitly, direction='both' is implied
        # and doesn't need to be specified (VectorBT warns if both are set)
        # Pass explicit exits so TP/SL logic from strategy is respected
        portfolio = vbt.Portfolio.from_signals(
            close=close_series,
            entries=long_entries_arr,
            exits=long_exits_arr,
            short_entries=short_entries_arr,
            short_exits=short_exits_arr,
            init_cash=config.initial_capital,
            fees=config.fees,
            slippage=config.slippage,
            size=config.size,
            size_type=vbt_size_type,
            freq=config.freq,
        )

        # Extract metrics from portfolio
        result = self._extract_metrics(portfolio, config)

        # Apply contract multiplier for futures if specified
        if config.contract_multiplier != 1.0:
            result = self._apply_contract_multiplier(result, config)

        return result

    def _extract_metrics(
        self,
        portfolio: vbt.Portfolio,
        config: BacktestConfig,
    ) -> BacktestResult:
        """Extract all metrics from VectorBT portfolio into BacktestResult.

        Args:
            portfolio: VectorBT Portfolio object after simulation.
            config: BacktestConfig used for the backtest.

        Returns:
            BacktestResult with all metrics populated.
        """
        # Get total return as decimal (0.15 = 15%)
        total_return = _safe_float(portfolio.total_return())

        # Get trade statistics
        # Note: portfolio.trades returns ExitTrades (closed trades) by default
        trades = portfolio.trades

        # Trade count
        n_trades = _safe_int(trades.count())

        # Win rate
        if n_trades > 0:
            win_rate = _safe_float(trades.win_rate())
        else:
            win_rate = 0.0

        # Profit factor
        if hasattr(trades, "profit_factor"):
            profit_factor = _safe_float(trades.profit_factor())
        else:
            profit_factor = 0.0

        # Average trade PnL
        if n_trades > 0 and hasattr(trades, "pnl"):
            avg_trade = _safe_float(trades.pnl.mean())
        else:
            avg_trade = 0.0

        # Max drawdown (as positive decimal, e.g., 0.20 = 20% drawdown)
        if hasattr(portfolio, "drawdowns") and hasattr(portfolio.drawdowns, "max_drawdown"):
            max_drawdown = abs(_safe_float(portfolio.drawdowns.max_drawdown()))
        else:
            max_drawdown = 0.0

        # Risk-adjusted ratios
        if hasattr(portfolio, "returns_acc"):
            returns_acc = portfolio.returns_acc
            sharpe_ratio = _safe_float(returns_acc.sharpe_ratio())
            sortino_ratio = _safe_float(returns_acc.sortino_ratio())
        else:
            sharpe_ratio = 0.0
            sortino_ratio = 0.0

        # Equity curve (portfolio value at each bar)
        equity_value = portfolio.value()
        if hasattr(equity_value, "values"):
            equity_curve = np.asarray(equity_value.values, dtype=np.float64)
        else:
            equity_curve = np.asarray(equity_value, dtype=np.float64)

        # Drawdown curve (percentage at each bar, negative values)
        running_max = np.maximum.accumulate(equity_curve)
        with np.errstate(divide="ignore", invalid="ignore"):
            drawdown_curve = np.where(
                running_max > 0,
                (equity_curve - running_max) / running_max,
                0.0,
            )
        drawdown_curve = np.asarray(drawdown_curve, dtype=np.float64)

        # Trades DataFrame
        if hasattr(trades, "records_readable"):
            trades_df = trades.records_readable
        else:
            # Fallback to empty DataFrame with expected columns
            trades_df = pd.DataFrame(
                columns=[
                    "Entry Time",
                    "Exit Time",
                    "Entry Price",
                    "Exit Price",
                    "PnL",
                    "Return",
                    "Duration",
                    "Direction",
                ]
            )

        # Compute config hash and timestamp
        config_hash = _compute_config_hash(config)
        timestamp = datetime.now(tz=timezone.utc).isoformat()

        return BacktestResult(
            total_return=total_return,
            sharpe_ratio=sharpe_ratio,
            sortino_ratio=sortino_ratio,
            max_drawdown=max_drawdown,
            win_rate=win_rate,
            profit_factor=profit_factor,
            n_trades=n_trades,
            avg_trade=avg_trade,
            equity_curve=equity_curve,
            drawdown_curve=drawdown_curve,
            trades=trades_df,
            config_hash=config_hash,
            timestamp=timestamp,
        )

    def _apply_contract_multiplier(
        self,
        result: BacktestResult,
        config: BacktestConfig,
    ) -> BacktestResult:
        """Apply futures contract multiplier to P&L-based metrics.

        VectorBT calculates P&L as price changes × contracts, but doesn't know
        about futures contract multipliers. This method scales all dollar-based
        metrics by the multiplier.

        For example, MGC: $10/point means a 10 point move on 1 contract = $100.
        VectorBT calculates: 10 points × 1 contract = $10 profit
        We scale: $10 × 10 multiplier = $100 profit (correct)

        Args:
            result: BacktestResult from VectorBT.
            config: BacktestConfig with contract_multiplier.

        Returns:
            BacktestResult with scaled metrics.
        """
        multiplier = config.contract_multiplier

        # Scale equity curve (portfolio value at each bar)
        # Profit portion = (equity - initial_capital)
        # Scaled profit = profit × multiplier
        # New equity = initial_capital + (scaled profit)
        scaled_equity = config.initial_capital + (
            (result.equity_curve - config.initial_capital) * multiplier
        )

        # Total return needs recalculation from scaled equity
        final_value = scaled_equity[-1]
        scaled_return = (final_value - config.initial_capital) / config.initial_capital

        # Drawdown curve needs recalculation from scaled equity
        running_max = np.maximum.accumulate(scaled_equity)
        with np.errstate(divide="ignore", invalid="ignore"):
            scaled_drawdown = np.where(
                running_max > 0,
                (scaled_equity - running_max) / running_max,
                0.0,
            )
        scaled_drawdown = np.asarray(scaled_drawdown, dtype=np.float64)

        # Max drawdown
        scaled_max_dd = abs(np.min(scaled_drawdown))

        # Average trade PnL (scale point profit to dollar profit)
        scaled_avg_trade = result.avg_trade * multiplier

        # Sharpe and Sortino are based on returns, which scale proportionally
        # Returns = profit / capital
        # Scaled returns = (profit × multiplier) / capital = returns × multiplier
        # Sharpe = mean(returns) / std(returns)
        # Scaled Sharpe = mean(returns × m) / std(returns × m) = Sharpe × m / m = Sharpe
        # Actually Sharpe stays the SAME because both numerator and denominator scale equally

        # However, we need to recalculate from scaled equity to be accurate
        returns_series = pd.Series(scaled_equity).pct_change().dropna()
        if len(returns_series) > 0:
            mean_return = returns_series.mean()
            std_return = returns_series.std()
            if std_return > 0:
                # Annualize assuming 252 trading days
                sharpe = (mean_return / std_return) * np.sqrt(252)
            else:
                sharpe = 0.0

            # Sortino uses only downside deviation
            downside_returns = returns_series[returns_series < 0]
            if len(downside_returns) > 0:
                downside_std = downside_returns.std()
                if downside_std > 0:
                    sortino = (mean_return / downside_std) * np.sqrt(252)
                else:
                    sortino = 0.0
            else:
                sortino = 0.0
        else:
            sharpe = 0.0
            sortino = 0.0

        # Trades DataFrame - scale PnL column if it exists
        scaled_trades = result.trades.copy()
        if 'PnL' in scaled_trades.columns:
            scaled_trades['PnL'] = scaled_trades['PnL'] * multiplier

        return BacktestResult(
            total_return=scaled_return,
            sharpe_ratio=sharpe,
            sortino_ratio=sortino,
            max_drawdown=scaled_max_dd,
            win_rate=result.win_rate,  # Win rate doesn't change
            profit_factor=result.profit_factor,  # Ratio doesn't change (scales cancel)
            n_trades=result.n_trades,  # Trade count doesn't change
            avg_trade=scaled_avg_trade,
            equity_curve=scaled_equity,
            drawdown_curve=scaled_drawdown,
            trades=scaled_trades,
            config_hash=result.config_hash,
            timestamp=result.timestamp,
        )


__all__: list[str] = ["BacktestEngine", "BacktestResult"]
